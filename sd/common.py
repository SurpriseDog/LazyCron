#!/usr/bin/python3
# An autogenerated selection of SurpriseDog's common functions relevant to this project.
# To see how this file was created visit: https://github.com/SurpriseDog/Star-Wrangler
# Written by SurpriseDog at: https://github.com/SurpriseDog

import os
import re
import sys
import csv
import time
import math
import queue
import shutil
import random
import socket
import threading
import subprocess
from urllib.parse import urlparse
from importlib.util import find_spec


def map_nested(func, array):
	"Apply a function to a nested array and return it"
	out = []
	for item in array:
		if type(item) not in (tuple, list):
			out.append(func(item))
		else:
			out.append(map_nested(func, item))
	return out


def bisect_small(lis, num):
	'''Given a sorted list, returns the index of the biggest number smaller than num
	Unlike bisect will never return an index which doesn't exist'''
	end = len(lis) - 1
	for x in range(end + 1):
		if lis[x] > num:
			return max(x - 1, 0)
	else:
		return end


class DotDict(dict):
	'''
	Example:
	m = dotdict({'first_name': 'Eduardo'}, last_name='Pool', age=24, sports=['Soccer'])

	Modified from:
	https://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
	to set unlimited chained .variables like DotDict().tom.bob = 3
	'''

	def __init__(self, *args, **kwargs):
		super(DotDict, self).__init__(*args, **kwargs)
		for arg in args:
			if isinstance(arg, dict):
				for k, v in arg.items():
					self[k] = v

		if kwargs:
			for k, v in kwargs.items():
				self[k] = v

	def __getattr__(self, attr):
		if attr in self:
			return self.get(attr)
		else:
			self[attr] = DotDict()
			return self[attr]

	def __setattr__(self, key, value):
		self.__setitem__(key, value)

	def __contains__(self, key):
		return bool(key in self.__dict__)

	def __setitem__(self, key, value):
		super(DotDict, self).__setitem__(key, value)
		self.__dict__.update({key: value})

	def __delattr__(self, item):
		self.__delitem__(item)

	def __delitem__(self, key):
		super(DotDict, self).__delitem__(key)
		del self.__dict__[key]


def dict_valtokey(dic, val):
	"Take a dictionary value and return the first key found:"
	for k, v in dic.items():
		if val == v:
			return k
	return None


def read_state(filename, multiline=False, forget=False, verbose=True, cleanup_age=86400):
	"todo make this a class"
	'''
	Maintains open file handles to read the state of a file without wasting resources
	forget =        open a file without maintaing open file handle
	multiline =     Return every stdout line instead of just the first.
	cleanup_age =   Minimum age to keep an old unaccessed file around before cleaning it up
	verbose =       1   Print a notification each time a new file opened
	verbose =       2   Print a notification each time a file is accesssed
	'''

	if verbose >= 2:
		print("Reading:", filename)

	# Open a file and don't add it to the log
	if forget:
		with open(filename, 'r') as f:
			if multiline:
				return list(map(str.strip, f.readlines()))
			else:
				return f.readline().strip()

	# Keep a dictionary of open files
	self = read_state
	now = time.time()
	if not hasattr(self, 'filenames'):
		self.filenames = dict()         # dictionary of filenames to file handles
		self.history = dict()           # When was the last time file was opened?
		self.last_cleanup = now         # Cleanup old files, occassionally
		# There is a limit to the number of open file handles.
		self.limit = 64                 # int(resource.getrlimit(resource.RLIMIT_NOFILE)[0] / 4)

	# Cleanup old unused file handles
	if cleanup_age and now - self.last_cleanup > cleanup_age / 2:
		self.last_cleanup = now
		for name in list(self.history.keys()):
			if name == filename:
				continue
			if now - self.history[name] > cleanup_age:
				print("Removing old file handle:", name)
				f = self.filenames[name]
				del self.filenames[name]
				del self.history[name]
				f.close()

	# Remove files if past the limit of file handles
	if len(self.filenames) > self.limit:
		earliest = sorted(list(self.history.values()))[0]
		name = dict_valtokey(self.history, earliest)
		print("\nToo many open handles! Removing:", name)
		f = self.filenames[name]
		f.close()
		del self.filenames[name]
		del self.history[name]

	# Open the file
	if filename not in self.filenames:
		if verbose:
			print("Opening", '#' + str(len(self.filenames) + 1) + ':', filename)
		try:
			f = open(filename, 'r')
		except BaseException:
			raise ValueError("Could not open: " + filename)
		self.filenames[filename] = f
	else:
		f = self.filenames[filename]
		f.seek(0)
	self.history[filename] = now

	# Return data
	if multiline:
		return list(map(str.strip, f.readlines()))
	else:
		return f.readline().strip()


def search_list(expr, the_list, getfirst=False, func='match', ignorecase=True, searcher=None):
	'''Search for expression in each item in list (or dictionary!)
	getfirst = Return the first value found, otherwise None
	searcher = Custom lamda function'''

	if not searcher:
		# func = dict(search='in').get('search', func)
		# Avoiding regex now in case substring has a regex escape character
		if ignorecase:
			expr = expr.lower()
		if func in ('in', 'search'):
			if ignorecase:
				def searcher(expr, item): 	      # pylint: disable=E0102
					return expr in item.lower()
			else:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return expr in item
		elif func == 'match':
			if ignorecase:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return item.lower().startswith(expr)
			else:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return item.startswith(expr)
		else:
			# Could have nested these, but this is faster.
			raise ValueError("Unknown search type:", func)

	output = []
	for item in the_list:
		if searcher(expr, item):
			if isinstance(the_list, dict):
				output.append(the_list[item])
			else:
				output.append(item)
			if getfirst:
				return output[0]
	return output


def check_internet(timeout=8, tries=1):
	"Check internet connection, return True if on"
	ips = ['8.8.8.8', '8.8.4.4', '1.1.1.1']
	for tri in range(tries):
		if tri:
			time.sleep(2)
		ip = random.choice(ips)
		try:
			socket.create_connection((ip, 53), timeout)
			return True
		except OSError:
			pass
	return False


def read_csv(filename, ignore_comments=True, cleanup=True, headers=None, merge=False, delimiter=',', **kargs):
	'''Read a csv while stripping comments and turning numbers into numbers
	ignore_comments = ignore a leading #
	cleanup = remove quotes and fix numbers
	headers = instead of a list return a dict with headers as keys for columns
	delimiter = seperator between columns.
	If you provide a list it will try each one in turn, but the first option must be a single character
	merge = merge repeated delimiter'''

	def clean(row):
		"Strip all the junk off of csv file"
		if not cleanup:
			return row
		out = []
		for item in row:
			# Cleanup any quote wraps
			item = item.strip()
			if item.startswith("'") and item.endswith("'"):
				item.strip("'")
			if item.startswith('"') and item.endswith('"'):
				item.strip('"')

			# Check if its a number
			if item.lstrip('-').replace('.', '', 1).isdigit():
				if '.' in item:
					item = float(item)
				else:
					item = int(item)
			out.append(item)
		return out

	def get_headers(row):
		if not headers:
			return row

		out = {key: None for key in headers}
		length = len(headers)
		count = 0
		for item in row:
			if count >= length:
				if item:
					print("Warning! Unused items while reading line:", row[count:])
				break
			out[headers[count]] = item
			count += 1
		return out

	with open(filename) as f:
		for line in f.readlines():
			if not line:
				yield get_headers(clean([]))

			if delimiter[0] in line:
				row = next(csv.reader([line], delimiter=delimiter[0], **kargs))
			else:
				for d in delimiter[1:]:
					if d in line:
						# This is fixed in python 3.7 anyway: https://github.com/PyCQA/pylint/issues/3424
						row = next(csv.reader([line.replace(d, delimiter[0])], delimiter=delimiter[0], **kargs))
						print("Using backup delimiter to read line:", repr(d))
						break
				else:
					continue

			if row:
				if merge:
					# Eliminate empty columns
					row = [item for item in row if item]
				if not ignore_comments:
					yield get_headers(clean(row))
				elif not row[0].startswith('#'):
					yield get_headers(clean(row))


def error(*args, header='\nError:', err=RuntimeError, **kargs):
	eprint(*args, header=header, v=3, **kargs)
	raise err


def safe_filename(filename, src="/ ", dest="-_", no_http=True, length=200, forbidden="*?\\/:<>|"):
	'''Convert urls and the like to safe filesystem names
	src, dest is the character translation table
	length is the max length allowed, set to 200 so rdiff-backup doesn't get upset
	forbidden characters are deleted'''
	if no_http:
		if filename.startswith("http") or filename.startswith("www."):
			netloc = urlparse(filename).netloc
			filename = filename[filename.find(netloc):]
			filename = re.sub("^www\\.", "", filename)
			filename = filename.strip('/')
	filename = filename.translate(filename.maketrans(src, dest)).strip()
	return ''.join(c for c in filename.strip() if c not in forbidden)[:length]


def joiner(char, *args):
	"Convert to string and join with character"
	if len(args) == 1 and type(args[0]) in (tuple, list):
		args = args[0]
	return char.join(map(str, args))


def mkdir(target, exist_ok=True, **kargs):
	"Make a directory without fuss"
	os.makedirs(target, exist_ok=exist_ok, **kargs)


def percent(num, digits=0):
	if not digits:
		return str(int(num * 100)) + '%'
	else:
		return sig(num * 100, digits) + '%'


def sorted_array(array, column=-1, reverse=False):
	"Return sorted 2d array line by line"
	pairs = [(line[column], index) for index, line in enumerate(array)]
	for _val, index in sorted(pairs, reverse=reverse):
		# print(index, val)
		yield array[index]


def avg(lis):
	"Average a list"
	return sum(lis) / len(lis)


def list_get(lis, index, default=''):

	# Fetch a value from a list if it exists, otherwise return default
	# Now accepts negative indexes
	length = len(lis)
	if -length <= index < length:
		return lis[index]
	else:
		return default


def read_file(filename):
	"Read an entire file into text"
	with open(filename, 'r') as f:
		return f.read()


def read_val(file):
	"Read a number from an open file handle"
	file.seek(0)
	return int(file.read())


def trailing_avg(lis, power=0.5):
	"Weighted average that biases the last parts of this list more:"
	total = 0
	weights = 0
	for index, num in enumerate(lis):
		weight = (index + 1)**power
		total += weight * num
		weights += weight
	return total / weights


def chunker(lis, lines=2, overlap=False):
	'''Take a list a return its values n items at a time
	alternate way: zip(*[iter(lis)]*n)'''
	if len(lis) <= lines:
		yield lis
	else:
		step = 1 if overlap else lines
		for start in range(0, len(lis) - lines + 1, step):
			yield lis[start:start + lines]


def quote(text):
	"Wrap a string in the minimum number of quotes to be quotable"
	for q in ('"', "'", "'''"):
		if q not in text:
			break
	else:
		return repr(text)
	if "\n" in text:
		q = "'''"
	return q + text + q


def msgbox(*args, title='Warning', wrap=640, wait=False):
	'''
	Popup message box, requires tkinter or zenity.
	Guaranteed not to break, even if third party libraries not installed.
	wait = wait for user to acknowledge before continuing
	returns False if message was not delivered to desktop
	'''
	msg = ' '.join(list(map(str, args)))

	def tk_box():
		"Messagebox with tkinter. Tkinter is imported here only after proven to exist"
		import tkinter as tk		# pylint: disable=C0415
		root = tk.Tk()
		root.title(title)
		lbl = tk.Label(root, font=("Arial", 12), text=msg, wraplength=wrap)
		lbl.pack(padx=10)
		button = tk.Button(root, text="Okay", command=root.destroy, width=10, font=("Arial", 12))
		button.pack(pady=10, padx=10)
		root.update()
		root.lift()
		time.sleep(len(msg)/64)
		root.mainloop()

	if find_spec("tkinter"):
		if wait:
			tk_box()
		else:
			spawn(tk_box)
		return True

	elif shutil.which('zenity'):
		cmd = ['zenity', '--width', str(len(msg)*10), '--info', '--timeout=99999999', '--text='+quote(msg)]
		if wait:
			ret = subprocess.run(cmd, check=False)
			return not bool(ret.returncode)
		else:
			subprocess.Popen(cmd)
			return True


	else:
		print("Install zenity or tkinter to get this message on the desktop:")
		print(msg)
		return False


def sig(num, digits=3):
	"Return number formatted for significant digits"
	if num == 0:
		return '0'
	negative = '-' if num < 0 else ''
	num = abs(float(num))
	power = math.log(num, 10)
	if num < 1:
		num = int(10**(-int(power) + digits) * num)
		return negative + '0.' + '0' * -int(power) + str(int(num)).rstrip('0')
	elif power < digits - 1:
		return negative + ('{0:.' + str(digits) + 'g}').format(num)
	else:
		return negative + str(int(num))


def rfs(num, mult=1000, digits=3, order=' KMGTPEZY', suffix='B', space=' '):
	'''A "readable" file size
	mult is the value of a kilobyte in the filesystem. (1000 or 1024)
	order is the name of each level
	suffix is a trailing character (B for Bytes)
	space is the space between '3.14 M' for 3.14 Megabytes

	'''
	if abs(num) < mult:
		return sig(num) + suffix
	# Faster than using math.log:
	for x in range(len(order) - 1, -1, -1):
		magnitude = mult**x
		if abs(num) >= magnitude:
			return sig(num / magnitude, digits) + space + (order[x] + suffix).rstrip()
	return str(num) + suffix		#Never called, but needed for pylint


def spawn(func, *args, daemon=True, delay=0, **kargs):
	'''Spawn a function to run seperately and return the que
	waits for delay seconds before running
	Get the results with que.get()
	Check if the thread is still running with thread.is_alive()
	print('func=', func, id(func))'''
	#replaces fork_cmd, mcall

	def worker():
		if delay:
			time.sleep(delay)
		ret = func(*args, **kargs)
		que.put(ret)

	que = queue.Queue()
	# print('args=', args)
	thread = threading.Thread(target=worker)
	thread.daemon = daemon
	thread.start()
	return que, thread


class _TmanObj():
	"Used for ThreadManager"

	def __init__(self, func, *args, delay=0, **kargs):
		self.start = time.time()
		self.que, self.thread = spawn(func, *args, delay=delay, **kargs)

	def age(self):
		return time.time() - self.start

	def is_alive(self):
		return self.thread.is_alive()


class ThreadManager():
	"Maintain a list of threads and when they were started, query() to see if done."

	def __init__(self):
		self.threads = dict()

	def query(self, func, *args, delay=0, max_age=0, **kargs):
		"Start thread if new, return status, que.get()"
		serial = id(func)

		obj = self.threads.get(serial, None)
		if max_age and obj and obj.age() > max_age:
			print("Thread aged out")
			del obj
			obj = None
		if obj and obj.is_alive():
			print("Can't get results now, we got quilting to do!")
			return False, None
		if obj:
			del self.threads[serial]
			return True, obj.que.get()

		# print("Starting thread!")
		obj = _TmanObj(func, *args, delay=delay, **kargs)
		self.threads[serial] = obj
		return False, None

	def remove(self, func):
		"Remove thread if in dict"
		serial = id(func)
		if serial in self.threads:
			del self.threads[serial]


def rint(num):
	return str(int(round(num)))


def shell(cmd, **kargs):
	"Return first line of stdout"
	return quickrun(cmd, **kargs)[0].strip()


def check_install(*programs, msg='', quitonerr=True):
	'''Check if program is installed (and reccomend procedure to install)
	programs is the list of programs to test
	prints msg if it can't find any and returns False'''

	errors = 0
	for program in programs:
		paths = shutil.which(program)
		if not paths:
			errors += 1
			print(program, 'is not installed.')
	if errors:
		if msg:
			if type(msg) == str:
				print("To install type:", msg)
			else:
				print("To install type:")
				for m in msg:
					print('\t' + m)
		else:
			print("Please install to continue...")
		if quitonerr:
			sys.exit(1)
		return False
	return True


class Eprinter:
	'''Drop in replace to print errors if verbose level higher than setup level
	To replace every print statement type: from common import eprint as print

	eprint(v=-1)    # Normally hidden messages
	eprint(v=0)     # Default level
	eprint(v=1)     # Priority messages
	eprint(v=2)     # Warnings
	eprint(v=3)     # Errors
	'''

	# Setup: eprint = Eprinter(<verbosity level>).eprint
	# Simple setup: from common import eprint
	# Usage: eprint(messages, v=1)

	# Don't forget they must end in 'm'
	BOLD = '\033[1m'
	WARNING = '\x1b[1;33;40m'
	FAIL = '\x1b[0;31;40m'
	END = '\x1b[0m'

	def __init__(self, verbose=0):
		self.level = verbose
		self.history = []

		#If string starts with '\n', look at history to make sure previous newlines don't exist
		self.autonewlines = True

	def newlines(self, num=1):
		"Print the required number of newlines after checking history to make sure they exist."
		lines = sum([1 for line in self.history[-num:] if not line.strip()])
		num -= lines
		if num:
			print('\n' * (num), end='')
		return num


	def eprint(self, *args, v=0, color=None, header=None, **kargs):
		'''Print to stderr
		Custom color example: color='1;33;40'
		More colors: https://stackoverflow.com/a/21786287/11343425
		'''
		verbose = v
		# Will print if verbose >= level
		if verbose < self.level:
			return 0

		if not color:
			if v == 2 and not color:
				color = f"{self.WARNING}"
			if v >= 3 and not color:
				color = f"{self.FAIL}" + f"{self.BOLD}"
		else:
			color = '\x1b[' + color + 'm'

		msg = ' '.join(map(str, args))
		if self.autonewlines:
			match = re.match('^\n*', msg)
			if match:
				num = self.newlines(match.span()[1])
				if num:
					#print('created', num, 'newlines', repr(msg[:64]))
					msg = msg.lstrip('\n')


		self.history += msg.splitlines()
		if len(self.history) > 64:
			self.history = self.history[64:]

		if header:
			msg = header + ' ' + msg
		if color:
			print(color + msg + f"{self.END}", file=sys.stderr, **kargs)
		else:
			print(msg, file=sys.stderr, **kargs)
		return len(msg)


def warn(*args, header="\n\nWarning:", delay=1 / 64):
	time.sleep(eprint(*args, header=header, v=2) * delay)


def flatten(tree):
	"Flatten a nested list, tuple or dict of any depth into a flat list"
	# For big data sets use this: https://stackoverflow.com/a/45323085/11343425
	out = []
	if isinstance(tree, dict):
		for key, val in tree.items():
			if type(val) in (list, tuple, dict):
				out += flatten(val)
			else:
				out.append({key: val})

	else:
		for item in tree:
			if type(item) in (list, tuple, dict):
				out += flatten(item)
			else:
				out.append(item)
	return out


def quickrun(*cmd, check=False, encoding='utf-8', errors='replace', mode='w', input=None,	# pylint: disable=W0622
			 verbose=0, testing=False, ofile=None, trifecta=False, hidewarning=False, **kargs):
	'''Run a command, list of commands as arguments or any combination therof and return
	the output is a list of decoded lines.
	check    = if the process exits with a non-zero exit code then quit
	testing  = Print command and don't do anything.
	ofile    = output file
	mode     = output file write mode
	trifecta = return (returncode, stdout, stderr)
	input	 = stdinput (auto converted to bytes)
	'''
	cmd = list(map(str, flatten(cmd)))
	if len(cmd) == 1:
		cmd = cmd[0]

	if testing:
		print("Not running command:", cmd)
		return []

	if verbose:
		print("Running command:", cmd)
		print("               =", ' '.join(cmd))

	if ofile:
		output = open(ofile, mode=mode)
	else:
		output = subprocess.PIPE

	if input:
		if type(input) != bytes:
			input = input.encode()

	#Run the command and get return value
	ret = subprocess.run(cmd, check=check, stdout=output, stderr=output, input=input, **kargs)
	code = ret.returncode
	stdout = ret.stdout.decode(encoding=encoding, errors=errors).splitlines() if ret.stdout else []
	stderr = ret.stderr.decode(encoding=encoding, errors=errors).splitlines() if ret.stderr else []

	if ofile:
		output.close()
		return []

	if trifecta:
		return code, stdout, stderr

	if code and not hidewarning:
		warn("Process returned code:", code)

	if not hidewarning:
		for line in stderr:
			print(line)

	return stdout


def gohome():
	os.chdir(os.path.dirname(sys.argv[0]))


def itercount(start=0, step=1):
	"Save an import itertools"
	x = start
	while True:
		yield x
		x += step


tman = ThreadManager()  # pylint: disable=C0103
qrun = quickrun		# pylint: disable=C0103
eprint = Eprinter(verbose=1).eprint     # pylint: disable=C0103

'''
&&&&%%%%%&@@@@&&&%%%%##%%%#%%&@@&&&&%%%%%%/%&&%%%%%%%%%%%&&&%%%%%&&&@@@@&%%%%%%%
%%%%%%%%&@&(((((#%%&%%%%%%%%%&@@&&&&&&%%%&&&&&%%%%%%%%%%%&&&&%&%#((((/#@@%%%%%%%
&&%%%%%%&@(*,,,,,,,/%&%%%%%%%&@@&&&&&%%&&&&%%&&%%%%%%%%%%&&&%#*,,,,,,*/&@&%%%%%%
%%%%%%%&@&/*,,,*,*,,*/%&%%%%%&@@&&&&&&%%&&&&&&&%%%%%%&%%%&&%*,,,,,,,,**#@&&%%%%%
&&&&&%%&@#(**********,*(#&%%%&@&&&&%%%%%%%%%&&&%%%%%%&%&&#*****,*******#@&&%%%%%
&&&%%%&&#/***/*****/*,**,*%&%&@@&&&&&&&&&&&&&&&%%%%%%&&#*,,,*/******/***(%&%%%%%
&&&%%%&%/*****///////**,,,,*/%%&&@@@@@@@@@@@@@@@@&&%#*,,,*,*(///////*****#%&%%%%
@@&%%#&#/,,,*/(//((((//**,,*/#&@@@@@&&&&&&&&&&@@@@@%(/*,,**/(/(((/(//*,,*(&&%%%%
&&&%##&#*,,,*////((((/*///(&@&@@&&&#%((//(/###%&@&@@@@#//**//(#(///***,.,/&&%%%%
%%%%%#%#*,,,**////(///((#&&&%@&%%(/*,,......,,/(#%&&&@@@%((/(/#(///**,,,,(&%%%%%
&&%%%#%%/,..***//(#(#%%&@@@&@%(*.,,..       ...,.,/#@&@@@&&%#(((///**,..,#%%%%%%
%&%%%%%#*,****/(##&@@@&@@@@&%*,....           ....,,(&@@@@@@&@&%((//****,(%%%%%%
%&%%%%%#/,**/#&@@@&@@@@@@@&(*,......    .     ..,..,.(&@@@@@@@&@@@&%#**,*(%%%%%%
&&%%%%#&#(#&@@@&@@@@@@@@%((#@@%&&((,,,,,..,,(**(%@@&@%##(&@@@@@@@@&&@@%#(%%%%%%%
&&&%%%%%&&&&&&@@@@@@%###%@(,%&/@@&(%(/*,..,*/%##&&,%@(*&@#((%&@@@@@@&&@&%%%%&&%%
&&%%%%%%&&&@@@@@@@@#((*#@%,#%%&@#%(/**//,****/(#%%%&&%*(@@*/#(&@@@@@@@&&%%%%%%%%
&&&%%%%%&@@@@&%#/,,,,*,(/%&@@&((%(*,*,,*,**,,*,*#%(#@@&%((**,,,,*#(%&@@&&%%%%%%%
&&&%%%%%@@@@%*/*,...,*,,/*#(//#****,***********,**/#/##(/*,*,...,*/*/&@@&%%&%%%%
&&%%%%%%&@@@(//,....,,*/****/,,/**************/***/,,//**/**,....,*//&@@&%%&%%%%
&&&%%%%%&@@%(/*,. ...,****/*/(//*%&@@&%%%%%%&&&&//*/(*/**/**......,/*#&@&%&&&&%%
&&%%%%%%&@@%(**,,....,/**/((/,#&&&&&%#((((((%&&&@&%/*/(/**/*,. ..,,*/((#@&&&&&&%
%&%%%%%%&&#(/**,..,,,***/((,./%&%&&&@&(/#((#@@&&&%&%,,/((*,/*,,..,,,///(%&%&&&&&
&&%%%%%%&#,**,.,..,,*(//(/,,.,&&&@#&@@##%(#&@&%%@&&#.,,/(((//*,,..,,**,*&%&&%&&&
&&%##%%%#/**,,,,..,*/((((*...,,#&##%(#%%&%%###%(%&/,.. **((((/,...,,,,**(%%#%%%&
&&%####(**,,,.,,.,,/(/(//*,,..../%&(##%&&&%%(#%&#, .. .**//(/(*,,..,.,,**/((#%%%
&&&%#///*,........,/(((//**,.   ,,(#%%%%%%&#%##**.   ,,*//((((*,........,*//(%%%
%%%%(/**...       .,/(((///*., .,*(#(%%%%%%%%##/*,..,,*///((/*.      .....**/(%%
%%%%#(,..          .,/((/(//****,/(((###%#%(#///**,,**/((/((*,          .,.,(%%%
&&%%%#/*...          ,*/(/(/((%%&#&#(/%./.*%(#%#%#&&(((/(/*,.          ..,**(&%%
&&%%%%(*.....          ..*((/**(#&&&&&&&%%%&%&&&%(/,*/((*..           .,..*(&&%%
&&%%%%&#*.      .        */(#/*,,*/((%#%%%%%((**,.*/(#(/,       .       ,(%&%%&%
%%%%%%&%#//**,..           .**(((*,...,,**,,..*,/((/*,.          ...,,//(#%%%%%%
%%%&&&%(/*,**,..,,.,..       .,,**//**,*,,,*,////*,,.        .,.,...,,,**//#%&%%
%%%&&%#/*,*,.    ...      ..         ...  ,.. .       .       ...   ..,,*/(#%&%%
&&&&&%(((*.*... . .*,.   .           .*%%#(,.          .    .*,. ..,.,,**/(%#&%%

Generated by https://github.com/SurpriseDog/Star-Wrangler
2021-08-10
'''
